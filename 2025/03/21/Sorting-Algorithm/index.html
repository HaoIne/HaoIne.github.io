<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Sorting Algorithm | HaoIne</title><meta name="author" content="HaoIne"><meta name="copyright" content="HaoIne"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Today, I’m learning sorting algorithm, and taking some notes in this passage. Selection SortI believe Selection Sort is the easiest sorting algorithm to understand, as it simply involves repeatedly fi">
<meta property="og:type" content="article">
<meta property="og:title" content="Sorting Algorithm">
<meta property="og:url" content="http://haoine.github.io/2025/03/21/Sorting-Algorithm/index.html">
<meta property="og:site_name" content="HaoIne">
<meta property="og:description" content="Today, I’m learning sorting algorithm, and taking some notes in this passage. Selection SortI believe Selection Sort is the easiest sorting algorithm to understand, as it simply involves repeatedly fi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://haoine.github.io/img/%E5%A4%B4%E5%83%8F.png">
<meta property="article:published_time" content="2025-03-21T00:59:24.000Z">
<meta property="article:modified_time" content="2025-03-30T03:11:08.133Z">
<meta property="article:author" content="HaoIne">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://haoine.github.io/img/%E5%A4%B4%E5%83%8F.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Sorting Algorithm",
  "url": "http://haoine.github.io/2025/03/21/Sorting-Algorithm/",
  "image": "http://haoine.github.io/img/%E5%A4%B4%E5%83%8F.png",
  "datePublished": "2025-03-21T00:59:24.000Z",
  "dateModified": "2025-03-30T03:11:08.133Z",
  "author": [
    {
      "@type": "Person",
      "name": "HaoIne",
      "url": "http://haoine.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://haoine.github.io/2025/03/21/Sorting-Algorithm/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Sorting Algorithm',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/%E5%A4%B4%E5%83%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">HaoIne</span></a><a class="nav-page-title" href="/"><span class="site-name">Sorting Algorithm</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Sorting Algorithm</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-21T00:59:24.000Z" title="发表于 2025-03-21 08:59:24">2025-03-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-30T03:11:08.133Z" title="更新于 2025-03-30 11:11:08">2025-03-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Today, I’m learning sorting algorithm, and taking some notes in this passage.</p>
<h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><p>I believe Selection Sort is the easiest sorting algorithm to understand, as it simply involves repeatedly finding the smallest elements in the unsorted portion of the array and swapping it with the first unsorted element.  </p>
<p>Let’s take a look at the implementation:</p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Section Sort */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">section_sort</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">  <span class="comment">// Outer loop: i represents the first elements&#x27; index of the unsorted portion.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// Find the index of the smallest element in the unsorted portion.</span></span><br><span class="line">    <span class="type">int</span> index_min = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[index_min] &gt; nums[j]) &#123; index_min = j; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Swap the found minimum element with the first unsorted element.</span></span><br><span class="line">    <span class="type">int</span> tmp = nums[index_min];</span><br><span class="line">    nums[index_min] = nums[i];</span><br><span class="line">    nums[i] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h2><p>Bubble Sort offers a slight improvement over Selection Sort because it’s an adaptive sorting algorithm that can be optimized using a flag.</p>
<h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bubble Sort */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">  <span class="comment">// Outer loop: i represents the index of the last unsorted elements.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = numsSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// Inner loop: &quot;Bubble&quot; the largest element in the unsorted portion to its correct position.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = nums[j];</span><br><span class="line">        nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">        nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Efficiency-Optimization"><a href="#Efficiency-Optimization" class="headerlink" title="Efficiency Optimization"></a>Efficiency Optimization</h3><p>We can <strong>observe</strong> that if no swaps occur during an inner loop <strong>iteration</strong>, the array is already sorted. This allows us to <strong>introduce</strong> a flag variable to <strong>track</strong> whether a swap has <strong>taken place</strong>. If no swaps occur, we can <strong>terminate</strong> the algorithm early, improving efficiency.</p>
<p>This optimization could decrease the time complexity to O(n) when the raw array is sorted.  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bubble Sort with Flag */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort_with_flag</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = numsSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// Set the flag variable.</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = nums[j];</span><br><span class="line">        nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">        nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">        <span class="comment">// Turns the flag to true if swap occurred.</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Notice: Even after the optimization, the max time complexity is still O(n^2).</em></p>
<h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><p>Insertion Sort is a <strong>practical</strong> and <strong>efficient</strong> sorting algorithm for small <strong>datasets</strong> due to its <strong>relatively</strong> low time complexity in such cases.</p>
<h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Insertion Sort */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertion_sort</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">  <span class="comment">// Outer loop: i represents the first elements of the unsorted portion.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">    <span class="comment">// Store nums[i] in a temporary variable base.</span></span><br><span class="line">    <span class="type">int</span> base = nums[i], j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Inner loop: shift the elements forward until encountering the correct position for base.</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base) &#123;</span><br><span class="line">      nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Place base to the correct position.</span></span><br><span class="line">    nums[j + <span class="number">1</span>] = base;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Algorithm-Characteristics"><a href="#Algorithm-Characteristics" class="headerlink" title="Algorithm Characteristics"></a>Algorithm Characteristics</h3><p>Insertion Sort is widely used due to it’s <strong>simplicity</strong> and <strong>efficiency</strong> in sorting small or <strong>nearly sorted</strong> datasets. While its <strong>worst-case</strong> time complexity is O(n^2), it generally performs better than Bubble Sort because it requires fewer element swaps.  </p>
<p>Additionally,  Insertion Sort is adaptive, meaning it performs <strong>particularly</strong> well when the input is already <strong>partially</strong> sorted. In the best case (when the array is already sorted), its time complexity is O(n), making it more efficient than many other simple sorting algorithms in such <strong>scenarios</strong>.</p>
<p>So, compared to Bubble Sort, Insertion Sort is often faster because it performs fewer operations in practice.</p>
<h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><p>As the name suggests, Quick Sort is a highly efficient sorting algorithm that <strong>leverages</strong> the divide-and-conquer strategy. It is widely used due to its excellent <strong>average-case</strong> time complexity and adaptability to various <strong>scenarios</strong>.</p>
<h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><p>The implementation of quick sort is more complex than the previous algorithms. Its core operation <strong>revolves around</strong> pivot partitioning.</p>
<ul>
<li><p>Pivot Partitioning</p>
<p>When processing an array, we first choose a pivot element and then rearrange the array such that all elements smaller than the pivot appear before it, while all larger elements appear after it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Pivot Partitioning */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> tmp = nums[x];</span><br><span class="line">  nums[x] = nums[y];</span><br><span class="line">  nums[y] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pivot Partitioning</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">  <span class="comment">// Choose the leftmost element as the pivot.</span></span><br><span class="line">  <span class="type">int</span> l = left, r = right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">    <span class="comment">// Notice: Here we must place the loop for r first, or l will be left + 1 when the array have been sorted, triggering the swapping between left and left + 1.</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] &gt;= nums[left]) &#123; r--; &#125;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] &lt;= nums[left]) &#123; l++; &#125;</span><br><span class="line">    swap(nums, l, r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Place left in the correct position.</span></span><br><span class="line">  swap(nums, left, l);</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Recursive Sorting</p>
<p>The partition function only partitions the array once. To fully sort the array, we must apply partitioning recursively.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Quick Sort */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">  <span class="comment">// Base case: Stop when the segment only contains 1 or 0 elements.</span></span><br><span class="line">  <span class="keyword">if</span>(left &lt;= right) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Partition the array and obtain the pivot index.</span></span><br><span class="line">  <span class="type">int</span> pivot = partition(nums, left, right);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recursively sort the left and right sub-arrays.</span></span><br><span class="line">  quick_sort(nums, left, pivot - <span class="number">1</span>);</span><br><span class="line">  quick_sort(nums, pivot + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Pivot-Optimization"><a href="#Pivot-Optimization" class="headerlink" title="Pivot Optimization"></a>Pivot Optimization</h3><p>Although Quick Sort is <strong>generally efficient</strong>, its performance can degrade under certain conditions. For example, when the input array is already sorted in reverse order and we always select the first element of the array. This results in highly unbalanced partitions, reducing Quick Sort to a worst-case O(n^2) complexity, similar to Bubble Sort.</p>
<p>To <strong>mitigate</strong> this issue, we could improve the pivot selection. A simple yet effective approach is to choose the median of three commonly used elements:</p>
<ul>
<li>Leftmost element</li>
<li>Middle element</li>
<li>Rightmost element</li>
</ul>
<p>This strategy increases the <strong>likelihood</strong> of selecting a pivot that creates balanced partitions, improving the <strong>overall efficiency</strong> of the algorithm.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Quick Sort (with optimization of pivot selection) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_pivot</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">  <span class="type">int</span> l = nums[left], m = nums[mid], r = nums[right];</span><br><span class="line">  <span class="comment">// Return the median of the three values.</span></span><br><span class="line">  <span class="keyword">if</span>((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l)) &#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m)) &#123;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Optimized Partitioning */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">  <span class="comment">// Choose pivot using the median-of-three strategy</span></span><br><span class="line">  <span class="type">int</span> pivot = select_pivot(nums, left, left + (right - left) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Move the pivot to the leftmost position.</span></span><br><span class="line">  swap(nums, left, pivot);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> l = left, r = right;</span><br><span class="line">  <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] &gt;= nums[left]) &#123; r--; &#125;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] &lt;= nums[left]) &#123; l++; &#125;</span><br><span class="line">    swap(nums, l, r);</span><br><span class="line">  &#125;</span><br><span class="line">  swap(nums, left, l);</span><br><span class="line">  <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The other part of the algorithm shouldn&#x27;t change.</span></span><br></pre></td></tr></table></figure>

<h3 id="Algorithm-Characteristics-1"><a href="#Algorithm-Characteristics-1" class="headerlink" title="Algorithm Characteristics"></a>Algorithm Characteristics</h3><p>Quick Sort remains one of the most efficient and widely used sorting algorithms, particularly due to its O(nlog(n)) average-case time complexity. While its worst-case performance can degrade to O(n^2), careful pivot selection strategy <strong>maintain</strong> its efficiency in practical scenarios.  </p>
<ul>
<li>Advantages<ul>
<li>fast</li>
<li>in-place</li>
</ul>
</li>
<li>Disadvantages<ul>
<li>unstable</li>
<li>time complexity will degrade under worst-case input.</li>
</ul>
</li>
</ul>
<h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><p>Merge Sort is also a highly efficient algorithm with a <strong>consistent</strong> time complexity of O(nlong(n)), making it a reliable choice for large <strong>datasets</strong>. It operates using the divide-and-conquer strategy, recursively breaking down the array into smaller sub-arrays before merging them back in sa sorted order.</p>
<h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><p>The core idea of Merge Sort is to <strong>repeatedly</strong> divide the input array into two smaller subarrays until each subarray contains only a single element. Then , pairs of subarrays are merged back together in <strong>sorted</strong> order to reconstruct the fully sorted array.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Merge Sort */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge two subarrays into a single sorted array.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">  <span class="comment">// Create a temporary array to store merged result.</span></span><br><span class="line">  <span class="type">int</span> tmp_size = right - left + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> *tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(tmp_size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define the pointers for both subarrays.</span></span><br><span class="line">  <span class="type">int</span> l = left, r = right, index_tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Merge elements in ascending order.</span></span><br><span class="line">  <span class="keyword">while</span>(l &lt;= mid &amp;&amp; r &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[l] &lt;= nums[r]) &#123;</span><br><span class="line">      tmp[tmp_index++] = nums[l++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[tmp_index++] = nums[r++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Append remaining elements from the both subarrays.</span></span><br><span class="line">  <span class="keyword">while</span>(l &lt;= mid) &#123;</span><br><span class="line">    tmp[tmp_index++] = nums[l++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(r &lt;= right) &#123;</span><br><span class="line">    tmp[tmp_index++] = nums[r++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy sorted elements back to the original array.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp_size; i++) &#123;</span><br><span class="line">    nums[left + i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursively sorts an array using Merge Sort.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">  <span class="comment">// Base case: Stop when the segment contains 1 or 0 elements.</span></span><br><span class="line">  <span class="keyword">if</span>(left &gt;= right) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the middle index.</span></span><br><span class="line">  <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recursively call merge_sort to sort the two subarrays.</span></span><br><span class="line">  merge_sort(nums, left, mid);</span><br><span class="line">  merge_sort(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The merging step.</span></span><br><span class="line">  merge(nums, left, mid, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Algorithm-Characteristics-2"><a href="#Algorithm-Characteristics-2" class="headerlink" title="Algorithm Characteristics"></a>Algorithm Characteristics</h3><p>Merge Sort is widely used when need to handling large datasets efficiently, or when stability is a key requirement.</p>
<ul>
<li>Advantages:<ul>
<li>Constantly Fast: time complexity is O(nlog(n)) whatever the input is.</li>
<li>Stable</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>Extra Space Usage: Merge Sort need a tmp array for instant restore.</li>
<li>more unit-operation: This feature makes it shows lower efficiency in small-database scenarios.</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://HaoIne.github.io">HaoIne</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://haoine.github.io/2025/03/21/Sorting-Algorithm/">http://haoine.github.io/2025/03/21/Sorting-Algorithm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://HaoIne.github.io" target="_blank">HaoIne</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/%E5%A4%B4%E5%83%8F.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/19/notes/miscs/archlinux/Configing-My-Arch/" title="Configing My Arch"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Configing My Arch</div></div><div class="info-2"><div class="info-item-1">In the last passage, I have talked about my experience of installing the basic system of Arch Linux.Ok, now we have Installed the base system of archlinux, and here it’s time to do some basic configurations.首先启动到 arch 系统，登录 root 账户。 创建普通账户啥事都用 root 用户做的话是有风险的，并且很多软件对于 root 用户是有限制的。所以当然，我们需要有一个普通账户 123[root]# useradd -m &lt;username&gt;...[root]# passwd &lt;username&gt;  上述命令创建一个名为 username 的用户，并且为其创建用户目录。 创建用户之后可以使用 su &lt;username&gt; 命令切换到新创建的用户 配置 sudosudo 可以让我们很方便地进行高权限操作。输入下列命令，使用 vim...</div></div></div></a><a class="pagination-related" href="/2025/03/24/notes/pwn/call_stack/" title="call_stack"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">call_stack</div></div><div class="info-2"><div class="info-item-1"> IA-32 (Intel 32位) 寄存器Note: 32 位说明栈中指针偏移量以 32位（4字节）为一个基元。  EAX ~ EDX: 通用寄存器 (general purpose registers)， 通用寄存器是通用的，但是有一部分指令对寄存器有特殊要求，这时它们分别有如下用途： EAX: 累加器 (“A” means Accumulator) EBX: 数据基地址暂存器 (“B” means Base) ECX: 循环计数器 (“C” means Counter) EDX: 操作数或操作结果暂存器 (“D” means Data)   为了方便存储较短的数据，通用寄存器都可以只使用低16位   ESI 和 EDI: 这两个寄存器优势也被包括在通用寄存器内，但是不能拆分，一般用作字符串操作的源指针和目的指针。 ESP 和 EBP: ESP 存储的是栈顶地址，即栈指针 (Stack Pointer)，而 EBP 存储的是位于栈顶的栈帧的栈底地址，即基指针 (Base Pointer)   控制权移交  控制权是指 CPU...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/%E5%A4%B4%E5%83%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">HaoIne</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" href="https://github.com/HaoIne/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Selection-Sort"><span class="toc-number">1.</span> <span class="toc-text">Selection Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation"><span class="toc-number">1.1.</span> <span class="toc-text">Implementation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bubble-Sort"><span class="toc-number">2.</span> <span class="toc-text">Bubble Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation-1"><span class="toc-number">2.1.</span> <span class="toc-text">Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Efficiency-Optimization"><span class="toc-number">2.2.</span> <span class="toc-text">Efficiency Optimization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Insertion-Sort"><span class="toc-number">3.</span> <span class="toc-text">Insertion Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation-2"><span class="toc-number">3.1.</span> <span class="toc-text">Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithm-Characteristics"><span class="toc-number">3.2.</span> <span class="toc-text">Algorithm Characteristics</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quick-Sort"><span class="toc-number">4.</span> <span class="toc-text">Quick Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation-3"><span class="toc-number">4.1.</span> <span class="toc-text">Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pivot-Optimization"><span class="toc-number">4.2.</span> <span class="toc-text">Pivot Optimization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithm-Characteristics-1"><span class="toc-number">4.3.</span> <span class="toc-text">Algorithm Characteristics</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Merge-Sort"><span class="toc-number">5.</span> <span class="toc-text">Merge Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation-4"><span class="toc-number">5.1.</span> <span class="toc-text">Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithm-Characteristics-2"><span class="toc-number">5.2.</span> <span class="toc-text">Algorithm Characteristics</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/23/notes/Full_stack_development_learning/foundations/foundations-the-box-model/" title="The Box Model">The Box Model</a><time datetime="2025-06-23T01:47:44.000Z" title="发表于 2025-06-23 09:47:44">2025-06-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/20/notes/Full_stack_development_learning/foundations/foundations-the-cascade/" title="The Cascade">The Cascade</a><time datetime="2025-06-20T06:17:29.000Z" title="发表于 2025-06-20 14:17:29">2025-06-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/18/notes/Full_stack_development_learning/foundations/foundation_intro_to_css/" title="Foundation Intro to CSS">Foundation Intro to CSS</a><time datetime="2025-06-18T07:06:08.000Z" title="发表于 2025-06-18 15:06:08">2025-06-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/12/notes/Full_stack_development_learning/foundations/javascript/" title="javascript">javascript</a><time datetime="2025-06-12T08:16:13.000Z" title="发表于 2025-06-12 16:16:13">2025-06-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/10/notes/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E4%BB%A3%E7%AC%94%E8%AE%B0/" title="线代笔记">线代笔记</a><time datetime="2025-06-10T02:51:49.000Z" title="发表于 2025-06-10 10:51:49">2025-06-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By HaoIne</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>